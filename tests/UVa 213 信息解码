# 救济金发放

## 题目
Message Decoding
Some message encoding schemes require that an encoded message be sent in two parts. The first part,called the header, contains the characters of the message. The second part contains a pattern that represents the message. You must write a program that can decode messages under such a scheme.The heart of the encoding scheme for your program is a sequence of “key” strings of 0’s and 1’s as 
follows:
···
0;00;01;10;000;001;010;011;100;101;110;0000;0001;…;1011;1110;00000;…
···
The rst key in the sequence is of length 1, the next 3 are of length 2, the next 7 of length 3, the next 15 of length 4, etc. If two adjacent keys have the same length, the second can be obtained from the rst by adding 1 (base 2). Notice that there are no keys in the sequence that consist only of 1’s. The keys are mapped to the characters in the header in order. That is, the first key (0) is mapped to the rst character in the header, the second key (00) to the second character in the header, the kth key is mapped to the kth character in the header. For example, suppose the header is:

AB#TANCnrtXc

Then 0 is mapped to A, 00 to B, 01 to #, 10 to T, 000 to A, …, 110 to X, and 0000 to c.

The encoded message contains only 0’s and 1’s and possibly carriage returns, which are to be ignored.The message is divided into segments. The rst 3 digits of a segment give the binary representationof the length of the keys in the segment. For example, if the rst 3 digits are 010, then the remainderof the segment consists of keys of length 2 (00, 01, or 10). The end of the segment is a string of 1’swhich is the same length as the length of the keys in the segment. So a segment of keys of length 2 is terminated by 11. The entire encoded message is terminated by 000 (which would signify a segmentin which the keyshave length 0). The message is decoded by translating the keys in the segments one-at-a-time into the header characters to which they have been mapped.

Input

The input le contains several data sets. Each data set consists of a header, which is on a single lineby itself, and a message, which may extend over several lines. The length of the header is limitedonly by the fact that key strings have a maximum length of 7 (111 in binary). If there are multiple copies of a character in a header, then several keys will map to that character. The encoded message contains only 0’s and 1’s,and it is a legitimate encoding according to the described scheme. That is, the message segments begin with the 3-digit length sequence and end with the appropriate sequence of1’s. The keys in any given segment are all of the same length, and they all correspond to characters in the header. The message is terminated by 000.

Carriage returns may appear anywhere within the message part. They are not to be considered as part of the message.

Output

For each data set, your program must write its decoded message on a separate line. There should not be blank lines between messages.

#### 样例输入：
```
TNM AEIOU 
0010101100011 
1010001001110110011 
11000 
$#** \ 
0100000101101100011100101000
```
#### 样例输出:
```
TAN ME 
##*\$
```

## 题意
n（n < 20）个人站成一圈，逆时针编号为1~n，有两个官员，A从1开始逆时针数，B从n开始顺时针数，在 **每一轮** 中，官员A数k个就停下来，官员B数m个就停下来
（注意有可能两个官员停在同一个人身上）。接下来被官员选中的人（1个或者两个）离开队伍

输入n，k，m输出每轮里被选中的人的编号，如果有两个人，先输出被A选中的，在输出B选中的， 输出的每个数应当恰好占3列。

------

## 分析

这是一道常规的暴力模拟题，

**首先**， 明确这是一个环的问题。有两种思路，一是用链表模拟，二则是用数组模拟。链表模拟思路更简明，这里采用数组模拟的方法。数组模拟要求在坐标越界时更改坐标位置。

**其次**， 明确顺时针和逆时针的区别，即+1和-1。

**再者**， 明确如何处理走出来的人，这里采用紫书的做法，走出即归为0。

## 源代码

```cpp
#include<cstdio>

#define maxn 25

int n, k, m, queue[maxn];

int go(int pos, int pace, int dis){
	
	while(dis){				//循环走一步的过程 
		
		do{					//跨过每一个走掉的人的位置 
			pos += pace;
			if(pos > n)		//形成环 
				pos -= n;
			if(pos < 1)		//形成环 
				pos += n; 
		}while(queue[pos] == 0);
		dis--;				//走完一步 

	}
	
	return pos;
}

int main(int argc, char* argv[]){
	
	while(3 == scanf("%d%d%d", &n, &k, &m) && n){ 
		
		int left = n;
		int pos1 = 0, pos2 = n+1;
		for(int i = 1; i <= n; i++)			//初始化编号 
			queue[i] = i;
		while(left){						//若环中还有人，则循环继续 
			pos1 = go(pos1, 1, k);			//官员数到下一个目标人员 
			pos2 = go(pos2, -1, m);
			if(pos1 == pos2){				//两个官员数的位置相同 
				left--;
				printf("%3d", queue[pos1]);
				queue[pos1] = 0;			//目标人员走出来 
			}else{							//两个官员数的位置不同
				left -= 2;					 
				printf("%3d%3d", queue[pos1], queue[pos2]);
				queue[pos1] = 0;			//目标人员走出来 
				queue[pos2] = 0;
			}
			if(left)
				printf(",");

		}
		printf("\n"); 
	}
	
	return 0;
}

```
