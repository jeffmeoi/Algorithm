# 小球下落

## 题目
[https://vjudge.net/problem/UVA-679](https://vjudge.net/problem/UVA-679)



#### 样例输入：
```
5
4 2
3 4
10 1
2 2
8 128
-1
```
#### 样例输出:
```
12
7
512
3
255
```

## 题意

有一棵二叉树，最大深度为D，且所有的叶子深度都相同。所有结点从上到下从左到右编号为1，2，3，…，2eD-1。在结点1处放一个小球，它会往下落。每个结点上都有一个开关，初始全部关闭，当每次有小球落到一个开关上时，它的状态都会改变。当小球到达一个内结点时，如果该结点的开关关闭，则往上走，否则往下走，直到走到叶子结点，如下图所示。

一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子数；D<=20。输出最多包含1000组数据。

------

## 分析

解法1(超时):
模拟法, 模拟出一棵二叉树, 每颗小球按照题目提供的思路走, 易于理解.

解法2:
当某个节点经过第n个小球时, 该节点的开关状态与只与奇偶有关. 若经过该节点的小球树木为奇数,则该节点可从左边通过,即k = k*2; 反之, 则右边通过, 即 k = k*2 + 1; 不断地往下一个深度延伸, 不断求出进入下一个深度时, 该节点的开关状态, 以判断进入左/右节点. 

## 源代码

```cpp
//解法1:(TLE)
#include<cstdio>
#include<cstring>
const int maxd = 20;
int s[1<<maxd];

int main(int argc, char* argv[]){
	
	int D, I;
	int T;
	scanf("%d", &T);
	while(T--){
		scanf("%d%d", &D, &I);
		memset(s, 0, sizeof(s));
		int k, n = (1<<D) - 1;
		for(int i = 0; i < I; i++){
			k = 1;
			for(;;){
				s[k] = !s[k];		//改变k处的开关 
				k = (s[k] ? k*2 : k*2+1);		//s[k]如果是打开的,则原本是关的,往左走;反之,往右走. 
				if(k > n)			//进入第D+1层后,k/2即为第D层的父节点编号. 
					break;
			}
		}
		printf("%d\n", k/2);
	}
	
	return 0;
}

 

//解法2:(正解)
#include <cstdio>
int main(){
	int T, D, I;
	scanf( "%d", &T );
	while ( T-- ){
		scanf( "%d%d", &D, &I );
		int k = 1;
		for ( int i = 0; i < D - 1; i++ )
			if ( I % 2 ){
				k = k * 2; I = (I + 1) / 2;
			}                               /* I即经过某一节点的小球数目 */
			else { k = k * 2 + 1; I /= 2; } /* 若经过该节点的小球树木为奇数,则该节点可从左边通过,即k = k*2; , 反之, 则右边通过, 即 k = k*2 + 1; */
		printf( "%d\n", k );
	}
	return(0);
}

```
