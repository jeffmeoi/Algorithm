# 信息解码

## 题目

Some message encoding schemes require that an encoded message be sent in two parts. The first part,called the header, contains the characters of the message. The second part contains a pattern that represents the message. You must write a program that can decode messages under such a scheme.The heart of the encoding scheme for your program is a sequence of “key” strings of 0’s and 1’s as 
follows:
···
0;00;01;10;000;001;010;011;100;101;110;0000;0001;…;1011;1110;00000;…
···
The rst key in the sequence is of length 1, the next 3 are of length 2, the next 7 of length 3, the next 15 of length 4, etc. If two adjacent keys have the same length, the second can be obtained from the rst by adding 1 (base 2). Notice that there are no keys in the sequence that consist only of 1’s. The keys are mapped to the characters in the header in order. That is, the first key (0) is mapped to the rst character in the header, the second key (00) to the second character in the header, the kth key is mapped to the kth character in the header. For example, suppose the header is:

AB#TANCnrtXc

Then 0 is mapped to A, 00 to B, 01 to #, 10 to T, 000 to A, …, 110 to X, and 0000 to c.

The encoded message contains only 0’s and 1’s and possibly carriage returns, which are to be ignored.The message is divided into segments. The rst 3 digits of a segment give the binary representationof the length of the keys in the segment. For example, if the rst 3 digits are 010, then the remainderof the segment consists of keys of length 2 (00, 01, or 10). The end of the segment is a string of 1’swhich is the same length as the length of the keys in the segment. So a segment of keys of length 2 is terminated by 11. The entire encoded message is terminated by 000 (which would signify a segmentin which the keyshave length 0). The message is decoded by translating the keys in the segments one-at-a-time into the header characters to which they have been mapped.

Input

The input le contains several data sets. Each data set consists of a header, which is on a single lineby itself, and a message, which may extend over several lines. The length of the header is limitedonly by the fact that key strings have a maximum length of 7 (111 in binary). If there are multiple copies of a character in a header, then several keys will map to that character. The encoded message contains only 0’s and 1’s,and it is a legitimate encoding according to the described scheme. That is, the message segments begin with the 3-digit length sequence and end with the appropriate sequence of1’s. The keys in any given segment are all of the same length, and they all correspond to characters in the header. The message is terminated by 000.

Carriage returns may appear anywhere within the message part. They are not to be considered as part of the message.

Output

For each data set, your program must write its decoded message on a separate line. There should not be blank lines between messages.

#### 样例输入：
```
TNM AEIOU 
0010101100011 
1010001001110110011 
11000 
$#**\ 
0100000101101100011100101000
```
#### 样例输出:
```
TAN ME 
##*\$
```

## 题意
对于下面这个字符串： 

```
0, 00, 01, 10, 000, 001, 010, 011, ... 
```

首先是长度为1的串，然后是长度为2的串，以此类推。不存在全为1的串。 
你的任务是编写一个程序。首先输入一个代码头（例如AB#TANCnrtXc），则上述序列的每个串依次对应编码头的每个字符。例如，0对应A，00对应B，01对应#…，0000对应c。接下来是编码文本（可能由多行组成，你应当把他们拼成一个长长的01串）。编码文本由多个小节组成，每个小节的前3个数字代表小节中每个编码的长度，用二进制表示，然后是个字符的编码，以全1结束。编码文本以000结束。

------

## 分析

这是一道考察函数知识的题目，用了各个函数的嵌套。题目没有考察算法知识，难在于题目的理解和字符的读入处理上。

过程为，读入编码头，换行即结束，读入编码文本，换行未结束。因此换行操作需要特殊处理。

编码文本读法为，读入n个小节，每个小节包含有，小节编码长度，多个编码，111（编码长度个1）。

编码头处理：每个字符分别与0， 00， 01， 10， …… 一一对应。序列长度为2时，序列最大值为10，即11（二进制）-1， 即((1<<2) -1)-1. 同理可得，序列长度为n时，序列最大值为((1<<n) -1) - 1.


## 源代码

```cpp
#include<cstdio>
#include<cstring>

#define maxn 1<<8

int code[8][maxn];

char readchar(){		//读入下一个非换行符号的字符 
	char c;
	while(true){
		c = getchar();
		if(c != '\r' && c != '\n')
			return c; 
	}
}

int readcodes(){		//读入所有的编码串 
	
	memset(code, 0, sizeof(code));			//init 
	code[1][0] = readchar();				//防止上一次循环的换行符被代入编码串 
	for(int i = 2; i <= 7; i++){
		for(int j = 0; j < (1<<i) -1 ; j++){
			int c = getchar();
			if(EOF == c)					//文件末尾即说明完成所有循环 
				return 0;
			if(c == '\r' || c == '\n')		//换行即说明读入完成 
				return 1;
			code[i][j] = c;
		}
	}
	
	return 1;
}

int printcodes(){							//打印出所有的代码检查是否正确 
	for(int i = 1; i <= 7; i++){
		for(int j = 0; j < (1<<i) -1 ; j++)
			printf("%c",code[i][j]);
		printf("\n");
	}
}


int getInt(int len){						//将len长度的二进制数转换成十进制整数 
	
	int num = 0;
	for(int i = 0; i < len; i++){
		int ch = readchar();
		num = num*2 + ch - '0';
	}
	
	return num;
}

int main(int argc, char * argv[]) {
	
	//freopen("UVa 213.in", "r", stdin);

	while(readcodes()){					//循环题目 
		//printcodes();
		while(true){					//循环读入小节 
			int len = getInt(3);		//编码长度 
			if(0 == len)				//即000 
				break;
			
			while(true){				//循环读入每个编码 
				int num = getInt(len);
				if((1<<len)-1 == num)	//即111（len个1） 
					break;
				putchar(code[len][num]);
				
			}
			
		}
		putchar('\n');
		
	}
	
	
	return 0;
}

```
