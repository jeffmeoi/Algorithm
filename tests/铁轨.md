# 铁轨

## 题目
[https://vjudge.net/problem/UVA-514](https://vjudge.net/problem/UVA-514)

#### 样例输入：
```
5
1 2 3 4 5
5 4 1 2 3
0
6
6 5 4 3 2 1
0
0

```
#### 样例输出:
```
Yes
No
Yes
```

## 题意

某城市有一个火车站，铁轨铺设如图所示。有n节车厢从A方向驶入车站，按进站顺序编号1～n。现让这些火车按照某种特定的顺序进入B方向的铁轨并驶出车站。为了重组车厢，可以借助中转站C。C是一个可以停放任意多节车厢的车站，但由于末端封顶，驶入C的车厢必须按照相反的顺序驶出C。对于每个车厢，一旦从A移入C，就不能再回到A了；一旦从C移入B，就不能回到C了。换句话说，在任意时刻，只有两种选择：A→C和C→B。请编程判断判断：按给定的出站顺序，火车能否出站。

------
 
## 分析

大半夜的做这道题目, 实在有些费脑筋. 这道题目考察的是栈的知识, 栈本身不难, 但这道题目的思维过程有一定的难度. 

我仔细地分析了一下这道题, 应该用高中生物老师教的来源与去路的方式来思考.

这道题的题设的目的是为了让车厢进入B处, 我们已知的是进入B中的车厢序列. 

那么先假定一种情况, 即已有n-1个车厢进入B中,已有p个车厢进入C中, 第n+p个车厢为A处的第一个车厢(设为D车厢)

所期待的B处的第n个车厢即```target[n]```(设为E车厢)只有两种来源, 一种来自A处, 另一种来自C处.

A处的车厢有两种情况, 一种是D车厢即为E车厢, 另一种是D车厢往后存在E车厢,即将E车厢及其往前的所有车厢都进栈, 再把栈顶的E车厢出栈.

C处的车厢只有栈顶的车厢可以直接出栈到B处, 所以只需判断栈顶的车厢是否为E车厢.

总结一下, 即, E车厢如果是D车厢, 直接将D车厢进栈出栈, 接着分析E车厢的下一个目标车厢即```target[n+1]```是来自栈顶或是来自D车厢往后的车厢. 如果都不是, 那么该所期待的出站顺序不存在. 如果E车厢不是D车厢, 也不是栈顶的车厢, 那么就先把D车厢进栈, 分析D车厢的下一个车厢. 

直到 所有车厢都按照所期待的出栈顺序 或 不存在所期待的出栈顺序 为止, 程序结束.

## 源代码

```cpp

#include <cstdio>
#include <stack>
using namespace std;
const int MAXN = 1000 + 10;

int n, target[MAXN];

int main()
{
	while ( scanf( "%d", &n ) == 1  && n)
	{
		while(true){
			stack<int>	s;
			int		A = 1, B = 1;
			int f;
			scanf("%d", &f);
			if(f == 0)
				break;
			target[1] = f;
			for ( int i = 2; i <= n; i++ )		//读入出站顺序 
				scanf( "%d", &target[i] );

			int ok = 1;
			while ( B <= n )
			{ 
				if ( A == target[B] ){			//如果下一个车厢(A处)与即将进入B处的第B个车厢序号相同,则将该车厢进栈并出栈到B处 
					A++;
					B++;
				}else if ( !s.empty() && s.top() == target[B] ){	//当下一个车厢(A处)与即将进入B处的第B个车厢序号不相同时,考虑是否为栈顶的车厢(C处最上端) 
					s.pop(); 
					B++;
				}else if ( A <= n )		//当下一个车厢(A处)与栈顶的车厢都和即将进入B处的第B个车厢序号不相同,先将下一个车厢(A处)进栈,考虑是否为下下个车厢(A处) 
					s.push( A++ );
				else {		//如果没有下个车厢(A处), 又不是栈顶的车厢, 则该出站顺序不可能实现. 
					ok = 0; 
					break; 
				}
			}
			printf( "%s\n", ok ? "Yes" : "No" );
		}
		printf("\n");
	}
	return(0);
}

```
